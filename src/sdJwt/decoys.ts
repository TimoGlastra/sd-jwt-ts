import { Hasher } from './hashDisclosure'
import { OrPromise } from '../types'
import { SdJwtError } from './error'

/**
 * Function which returns a salt generated by a CSPRNG.
 *
 * Recommended size is 128 bits (i.e. 16 bytes).
 *
 * Salts will not be seeded and a new one will be used for each claim.
 *
 * @example
 *
 * Node.js: `crypto.randomBytes(128 / 8)`
 *
 * React Native: `expo-standard-web-crypto`
 *
 * Browser: `crypto.getRandomValues(new Uint8Array(128 / 8))`
 */
export type SaltGenerator = () => OrPromise<string>

export const createDecoys = async (
    count: number,
    saltGenerator: SaltGenerator,
    hasher: Hasher
) => {
    if (count < 0) {
        throw new SdJwtError(`Negative count of ${count} is not allowed.`)
    }

    if (isNaN(count)) {
        throw new SdJwtError(`NaN is not allowed for count.`)
    }

    if (!isFinite(count)) {
        throw new SdJwtError(`Infinite is not allopwed for count.`)
    }

    const decoys: Array<string> = []
    for (let i = 0; i < count; i++) {
        const salt = await saltGenerator()
        const decoy = await hasher(salt)
        decoys.push(decoy)
    }
    return decoys
}
